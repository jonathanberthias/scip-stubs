"""
Variant of stubtest that just checks the methods in classes
and ensures the order is the same in the source and in the stubs.
"""

from __future__ import annotations

import difflib
import re
import sys
from pathlib import Path

# Methods that are in the source .pxi files but not in the stubs
IGNORES = [
    ("Column", "__init__"),
    ("Event", "__str__"),
    ("Expr", "__next__"),
    ("Model", "__eq__"),
    ("*", "__dealloc__"),
    ("*", "__eq__"),
    ("*", "__ge__"),  # generated by __richcmp__
    ("*", "__le__"),  # generated by __richcmp__
    ("*", "__nonzero__"),
    ("*", "__repr__"),
    ("*", "__richcmp__"),  # generates all comparison operations
    ("*", "name"),  # method (property) in the stubs, attribute in source
]


def get_methods_by_class(lines: list[str]) -> dict[str, list[str]]:  # noqa: C901
    classes: dict[str, list[str]] = {}
    current_class = None
    for i, line in enumerate(lines):
        m = re.match(r"^(?:cdef )?class (\w+)", line)
        if m:
            name = m.group(1)
            if i > 0 and lines[i - 1] != "@type_check_only":
                current_class = name
                classes[current_class] = []
        elif "cdef" in line:
            continue
        elif line and not line.startswith("  ") and not line.startswith("\t"):
            current_class = None
        elif current_class:
            # Some files have 2 spaces indentation
            m = re.match(r"\s{2,4}def (\w+)\(", line)
            if not m:
                continue
            fname = m.group(1)
            if fname.startswith("_") and not fname.startswith("__"):
                continue  # private
            if (current_class, fname) in IGNORES or ("*", fname) in IGNORES:
                continue
            if fname in classes[current_class]:
                continue  # an overload, don't repeat
            classes[current_class].append(fname)
    return dict(classes)


def load_scip_source() -> list[str]:
    venv_lib = Path(__file__).absolute().parent.parent / ".venv/lib"
    pyscipopt = venv_lib.glob("python*/site-packages/pyscipopt")
    scip_dir = next(pyscipopt)
    sources = scip_dir.glob("*.pxi")

    scip_lines = []
    for scip_file in sources:
        scip_lines.extend(scip_file.read_text().splitlines())
    return scip_lines


def load_stub_source() -> list[str]:
    stub_file = Path(__file__).parent.parent / "pyscipopt/scip.pyi"
    return stub_file.read_text().splitlines()


def compare() -> int:
    scip_source = load_scip_source()
    stub_source = load_stub_source()
    stub_methods = get_methods_by_class(stub_source)
    scip_methods = get_methods_by_class(scip_source)

    scip_keys = set(scip_methods)
    stub_keys = set(stub_methods)
    stub_extra = stub_keys - scip_keys
    assert not stub_extra, f"Extra classes in stub: {stub_extra}"
    scip_extra = scip_keys - stub_keys
    assert not scip_extra, f"Extra classes in scip: {scip_extra}"

    status = 0
    for klass in stub_methods:
        scip_meths = scip_methods[klass]
        stub_meths = stub_methods[klass]
        diff = list(
            difflib.unified_diff(
                stub_meths, scip_meths, "stub", "source", n=1, lineterm=""
            )
        )
        if diff:
            status += 1
            print(klass)
            print(end="\t")
            print("\n\t".join(diff))
    return status


def reorder(classname: str) -> None:
    scip_source_lines = load_scip_source()
    stub_source_lines = load_stub_source()
    scip_methods = get_methods_by_class(scip_source_lines)[classname]

    classdef_re = re.compile(rf"(cdef )?class {classname}[\(:]")

    class_start = 0
    for i, line in enumerate(stub_source_lines):
        if classdef_re.match(line):
            class_start = i
            break
    else:
        raise ValueError(f"Class {classname} not found in stub")
    stub_source_lines = stub_source_lines[class_start + 1 :]

    def find_end() -> int:
        for i, line in enumerate(stub_source_lines):
            if line and not line.startswith(" "):
                return i
        raise ValueError("End of class not found")

    class_end = find_end()
    stub_source_lines = stub_source_lines[:class_end]

    stub_source = "\n".join(stub_source_lines)
    funcs = re.findall(
        r'(def (\w+)\(.*?\)(?: -> [, "\[\]\w]+)?:\s*(?:""".*?""")?(?:...)?(?:[# \w]*)(?=\n\s*def|$))',
        stub_source,
        re.DOTALL | re.MULTILINE,
    )
    source_by_name = {fname: func for func, fname in funcs}
    new_source = []
    for meth in scip_methods:
        if meth not in source_by_name:
            print(f"Method {meth} not found in stubs")
            continue
        new_source.append(source_by_name[meth])
    new_source = "    " + "\n    ".join(new_source)
    print(new_source)


if __name__ == "__main__":
    if len(sys.argv) > 1:
        reorder(sys.argv[1])
    else:
        sys.exit(compare())
